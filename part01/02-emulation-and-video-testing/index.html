<!DOCTYPE html><html lang="en" class="no-js"><head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A practical reference for building glass-to-glass video pipelines on constrained hardware. This site complements the code by explaining design choices, failure modes, and observed behavior across the system.">
      
      
      
        <link rel="canonical" href="https://gtog.dev/part01/02-emulation-and-video-testing/">
      
      
        <link rel="prev" href="../01-rust-on-pi/">
      
      
      
        
      
      
        <link rel="alternate" type="application/rss+xml" title="RSS feed" href="../../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="RSS feed of updated content" href="../../feed_rss_updated.xml">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Integration Testing for Linux Video Pipelines - Glass-to-Glass Video Pipeline</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      

  
  
  
  
  <style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M17%2013h-4v4h-2v-4H7v-2h4V7h2v4h4m-5-9A10%2010%200%200%200%202%2012a10%2010%200%200%200%2010%2010%2010%2010%200%200%200%2010-10A10%2010%200%200%200%2012%202%22/%3E%3C/svg%3E');}</style>


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  

<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-8XBZY8WGLD"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-8XBZY8WGLD",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-8XBZY8WGLD",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
  <link href="../../assets/stylesheets/glightbox.min.css" rel="stylesheet"><script src="../../assets/javascripts/glightbox.min.js"></script><style id="glightbox-style">
            html.glightbox-open { overflow: initial; height: 100%; }
            .gslide-title { margin-top: 0px; user-select: text; }
            .gslide-desc { color: #666; user-select: text; }
            .gslide-image img { background: white; }
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color); }
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color); }
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color); }
        </style></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#integration-testing-for-linux-video-pipelines" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Glass-to-Glass Video Pipeline" class="md-header__button md-logo" aria-label="Glass-to-Glass Video Pipeline" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Glass-to-Glass Video Pipeline
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Integration Testing for Linux Video Pipelines
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo" aria-label="Switch to light mode" type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"></path></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo" aria-label="Switch to dark mode" type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo" aria-label="Switch to system preference" type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/astavonin/glass-to-glass" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"></path></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
  
    
  
  Frame Capture

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Glass-to-Glass Video Pipeline" class="md-nav__button md-logo" aria-label="Glass-to-Glass Video Pipeline" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg>

    </a>
    Glass-to-Glass Video Pipeline
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/astavonin/glass-to-glass" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"></path></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    
  
    Frame Capture
  

    
  </span>
  
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Frame Capture
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-rust-on-pi/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Cross-Compiling Rust for Raspberry Pi
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Integration Testing for Linux Video Pipelines
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Integration Testing for Linux Video Pipelines
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#why-linux-is-unusually-amenable-to-this-kind-of-integration-testing" class="md-nav__link">
    <span class="md-ellipsis">
      
        Why Linux is unusually amenable to this kind of integration testing
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#making-the-environment-deterministic" class="md-nav__link">
    <span class="md-ellipsis">
      
        Making the environment deterministic
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#using-kernel-provided-virtual-devices-vivid" class="md-nav__link">
    <span class="md-ellipsis">
      
        Using kernel-provided virtual devices (vivid)
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#structuring-integration-tests-around-virtual-devices" class="md-nav__link">
    <span class="md-ellipsis">
      
        Structuring integration tests around virtual devices
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#validating-frame-content-and-metadata" class="md-nav__link">
    <span class="md-ellipsis">
      
        Validating frame content and metadata
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="integration-testing-for-linux-video-pipelines">Integration Testing for Linux Video Pipelines<a class="headerlink" href="#integration-testing-for-linux-video-pipelines" title="Permanent link">¶</a></h1>
<div class="admonition example">
<p class="admonition-title">Example</p>
<p>If you just want the end result, use the repo diff as a reference: <a href="https://github.com/astavonin/pi-cam-capture/compare/ci-and-cross...emulation-and-video-testing?diff">pi-cam-capture?diff</a>.</p>
<p>It shows the exact changes covered in this article, as they exist in the repository today, without extra commentary.</p>
</div>
<p>Most embedded Linux projects end up with the same testing setup. Unit tests cover parts of the logic, often in a patchy way, because syscalls and OS behavior are out of scope. Hardware-in-the-loop is used to check that the system works on the real device. Even in theory, this combination is weak and fragile, but in many teams it is still treated as "good enough". The blind spot is always the same. The boundary between user space and the kernel is rarely exercised during normal development, even though that is where a large share of real failures occur.</p>
<p>In Linux-based video systems, most application code does not manipulate pixels directly. It involves negotiating formats via ioctls, allocating and mapping buffers, handling blocking semantics, and interpreting metadata produced by drivers. This boundary is where failures cluster, and it is precisely the part of the system that neither unit tests nor HIL handles well.</p>
<p>Unit tests cannot exercise kernel behavior in any meaningful way. In the best case, they replace file descriptors, ioctls, and device state with mocks, which is fine for checking control flow and error handling. What disappears is the behavior that actually matters in video processing. Buffer queues have ordering and lifetime rules. Some ioctls return success while silently adjusting parameters. Others block depending on the driver's state. Timestamps have specific origins and invariants. These details define how a video device behaves, and a mock cannot realistically reproduce them.</p>
<p>And quite often the result is predictable. Code passes unit tests while embedding incorrect assumptions about alignment, stride, buffer lifetime, or sequencing. These assumptions remain invisible until the first interaction with a real device.</p>
<p>At that point, teams fall back to hardware-in-the-loop testing. HIL does exercise the real kernel interface, but it usually happens late and at a high cost. Access to hardware is often limited, setup can be slow, failures may be non-deterministic, and reproducing issues relies heavily on the physical context. When integration problems arise only at this stage, the iteration process can slow down significantly. Continuous Integration (CI) provides little support in this scenario. While it is sometimes possible to wire HIL into a CI pipeline, it tends to be fragile and hard to maintain reliability, which means these paths are not exercised consistently, and regressions reappear.</p>
<p>This creates a systemic blind spot. Unit tests validate logic in an environment that cannot fail in realistic ways. HIL validates behavior in an environment that is expensive and difficult to automate. The kernel boundary, where most integration bugs originate, remains largely untested during normal development. For Linux video systems, this is not an edge case. It is the dominant failure mode.</p>
<p>This gap is structural, not accidental. It comes from how different test layers interact with the system stack and which boundaries they actually cross.</p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="../img/02.01-testing-layers.png" data-desc-position="bottom"><img alt="" src="../img/02.01-testing-layers.png" width="640"></a></p>
<p>The diagram shows how coverage is distributed across a Linux video, or any other typical embedded system. Unit tests remain confined to application logic and never cross into the kernel. Hardware-in-the-loop testing exercises the full stack, but it sits outside the normal development loop and is expensive to run continuously. Virtual-device integration tests occupy the middle ground. They drive real syscalls and kernel code paths through emulated drivers, allowing the user-space-to-kernel boundary to be exercised early, repeatedly, and in CI, without relying on physical hardware.</p>
<h2 id="why-linux-is-unusually-amenable-to-this-kind-of-integration-testing">Why Linux is unusually amenable to this kind of integration testing<a class="headerlink" href="#why-linux-is-unusually-amenable-to-this-kind-of-integration-testing" title="Permanent link">¶</a></h2>
<p>Integration testing with virtual devices usually works on Linux because most hardware interaction already goes through the kernel. From the user space, the boundary is not registers or buses. It is file descriptors, ioctls, memory mappings, and kernel metadata. These boundaries are explicit, documented, and often straightforward to virtualize.</p>
<p>For video capture, the contract is V4L2. V4L2 allows us to discover devices via <code>/dev/video*</code> and to obtain capabilities, formats, and controls via standardized ioctls. Buffers are exchanged via MMAP or USERPTR with well-defined lifetime rules. Metadata such as timestamps and sequence numbers follow documented semantics. At the end, from the user space, a physical camera and a virtual camera look identical as long as they speak the same kernel API. In practice, this is visible directly through standard V4L2 tooling. A real camera and a virtual device appear identical at the kernel boundary.</p>
<div class="highlight"><pre><span></span><code>➜<span class="w"> </span>v4l2-ctl<span class="w"> </span>--list-devices
vivid<span class="w"> </span><span class="o">(</span>platform:vivid-000<span class="o">)</span>:
<span class="w">        </span>/dev/video2

Integrated<span class="w"> </span>Camera:<span class="w"> </span>Integrated<span class="w"> </span>C<span class="w"> </span><span class="o">(</span>usb-0000:00:14.0-6<span class="o">)</span>:
<span class="w">        </span>/dev/video0
</code></pre></div>
<p>Such contracts are a key difference from bare-metal or tightly coupled firmware systems. In Linux, the kernel already sits between your code and the hardware, enforcing an abstraction. That abstraction can often be backed by a real driver or a virtual one with identical user-space behavior. As long as the driver implements the same V4L2 contract, the application code exercises the same paths.</p>
<p>Linux also exposes enough system state to enable deterministic discovery and selection. Sysfs provides device identity, driver names, and topology under <code>/sys/class</code>. Procfs exposes the runtime context that affects behavior. Instead of guessing which <code>/dev/video0</code> is present, code and tests can identify devices by driver and capabilities, and fail explicitly when expectations are not met.</p>
<p>This makes Linux an incredibly practical test harness that helps to keep your codebase stable. Your integration tests are production-like in the sense that you can run real syscalls, negotiate real formats, allocate real buffers, and observe real blocking behavior without needing physical hardware attached. The kernel enforces the same rules either way.</p>
<p>For video systems, this matters in practice. Most integration failures are not sensor-specific. They come from incorrect assumptions about format negotiation, buffer handling, timing, or sequencing. These failures live at the kernel interface. Exercising that interface deterministically catches a large class of bugs early.</p>
<h2 id="making-the-environment-deterministic">Making the environment deterministic<a class="headerlink" href="#making-the-environment-deterministic" title="Permanent link">¶</a></h2>
<p>Integration tests that touch kernel interfaces only make sense if the environment is predictable. If setup depends on manual steps or undocumented assumptions, failures become ambiguous and easy to dismiss. This is where many teams stop trusting integration tests altogether.</p>
<p>For V4L2, the environment includes user space tools, kernel support, and the way devices appear under <code>/dev</code> and <code>/sys</code>. In this project, those assumptions are encoded directly in a setup script rather than documented separately.</p>
<p><a href="https://github.com/astavonin/pi-cam-capture/blob/emulation-and-video-testing/scripts/dev-setup.sh">The script</a> starts by installing and verifying the required user space tooling. If inspection tools are missing, there is no point in proceeding.</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span>cmd<span class="w"> </span><span class="k">in</span><span class="w"> </span>v4l2-ctl<span class="w"> </span>ffmpeg<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">command</span><span class="w"> </span>-v<span class="w"> </span><span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span><span class="w"> </span><span class="p">&amp;</span>&gt;/dev/null<span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span>success<span class="w"> </span><span class="s2">"</span><span class="nv">$cmd</span><span class="s2"> installed"</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span>error<span class="w"> </span><span class="s2">"</span><span class="nv">$cmd</span><span class="s2"> not found"</span>
<span class="w">        </span><span class="nv">ok</span><span class="o">=</span><span class="nb">false</span>
<span class="w">    </span><span class="k">fi</span>
<span class="k">done</span>
</code></pre></div>
<p>Kernel support is checked explicitly. Virtual devices only work if the driver is available for the running kernel, and this varies by distribution.</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span>mod<span class="w"> </span><span class="k">in</span><span class="w"> </span>vivid<span class="w"> </span>v4l2loopback<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span>modinfo<span class="w"> </span><span class="s2">"</span><span class="nv">$mod</span><span class="s2">"</span><span class="w"> </span><span class="p">&amp;</span>&gt;/dev/null<span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span>success<span class="w"> </span><span class="s2">"</span><span class="nv">$mod</span><span class="s2"> module available"</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span>warn<span class="w"> </span><span class="s2">"</span><span class="nv">$mod</span><span class="s2"> module not available"</span>
<span class="w">    </span><span class="k">fi</span>
<span class="k">done</span>
</code></pre></div>
<p>Loading the virtual camera is a deliberate step with fixed parameters. The configuration is part of the test contract, not an implementation detail.</p>
<div class="highlight"><pre><span></span><code><span class="nv">$SUDO</span><span class="w"> </span>modprobe<span class="w"> </span>vivid<span class="w"> </span><span class="nv">n_devs</span><span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="nv">node_types</span><span class="o">=</span>0x1,0x1<span class="w"> </span><span class="nv">input_types</span><span class="o">=</span>0x81,0x81
</code></pre></div>
<p>After loading the module, the script validates the result from user space. Tests do not assume devices exist; they require them.</p>
<div class="highlight"><pre><span></span><code><span class="nv">$SUDO</span><span class="w"> </span>v4l2-ctl<span class="w"> </span>--list-devices
</code></pre></div>
<p>At this point, the environment is in a known state. Virtual video devices exist, they are discoverable through standard V4L2 tooling, and they expose the same kernel interfaces as physical cameras. Integration tests can rely on this without special casing or fallback logic.</p>
<p>The script also configures deterministic test patterns on each vivid device, using sysfs to identify them and <code>v4l2-ctl</code> to apply known formats and patterns.</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span>v4l2-ctl<span class="w"> </span>-d<span class="w"> </span><span class="s2">"</span><span class="nv">$dev</span><span class="s2">"</span><span class="w"> </span>--set-fmt-video<span class="o">=</span><span class="nv">width</span><span class="o">=</span><span class="m">640</span>,height<span class="o">=</span><span class="m">480</span>,pixelformat<span class="o">=</span>YUYV<span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span>success<span class="w"> </span><span class="s2">"</span><span class="nv">$dev</span><span class="s2">: Set format to 640x480 YUYV"</span>
<span class="k">fi</span>

v4l2-ctl<span class="w"> </span>-d<span class="w"> </span><span class="s2">"</span><span class="nv">$dev</span><span class="s2">"</span><span class="w"> </span>--set-ctrl<span class="o">=</span><span class="nv">test_pattern</span><span class="o">=</span><span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span>
</code></pre></div>
<p>This ensures that integration tests see predictable frame content, not just “some bytes”.</p>
<p>Finally, teardown is explicit. Kernel state is global, and CI runs must clean up after themselves.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Kernel state is global. It is safe to run multiple integration tests in parallel on a runner that has been preconfigured with <code>vivid</code> already loaded. <strong>CI jobs that load or unload kernel modules must not run concurrently on the same runner</strong>.</p>
</div>
<div class="highlight"><pre><span></span><code><span class="nv">$SUDO</span><span class="w"> </span>modprobe<span class="w"> </span>-r<span class="w"> </span>vivid
</code></pre></div>
<p>The result is a setup that either succeeds and is validated, or fails immediately. When an integration test fails, the failure comes from the code under test, not from an unclear or partially configured environment.</p>
<h2 id="using-kernel-provided-virtual-devices-vivid">Using kernel-provided virtual devices (<code>vivid</code>)<a class="headerlink" href="#using-kernel-provided-virtual-devices-vivid" title="Permanent link">¶</a></h2>
<p>With a deterministic environment in place, the next question is what the integration tests should talk to. For V4L2, the choice is straightforward. Mock devices in user space do not exercise the kernel boundary. Physical cameras reintroduce cost and instability. The practical middle ground is to use a kernel driver that implements the same V4L2 contract as real hardware.</p>
<p>On Linux, that driver is <code>vivid</code>.</p>
<p>From user space, the application does not talk to hardware directly. It talks to the V4L2 API. Whether the request is handled by a physical camera driver or a virtual one is an implementation detail hidden behind the kernel interface.</p>
<p><a class="glightbox" data-type="image" data-width="auto" data-height="auto" href="../img/02.02-V4L2-interface.png" data-desc-position="bottom"><img alt="" src="../img/02.02-V4L2-interface.png" width="640"></a></p>
<p>This is why vivid works for integration testing. It registers <code>/dev/video*</code> nodes and implements the same ioctls, buffer APIs, and metadata semantics as real capture devices. The code under test follows the same execution paths either way.</p>
<p>This equivalence is visible directly through standard tooling. A physical camera and a vivid device are discovered in the same way:</p>
<div class="highlight"><pre><span></span><code>➜ v4l2-ctl --list-devices
vivid (platform:vivid-000):
        /dev/video2

Integrated Camera: Integrated C (usb-0000:00:14.0-6):
        /dev/video0
</code></pre></div>
<p>Capabilities are queried through the same ioctls and expose the same capture and streaming flags:</p>
<div class="highlight"><pre><span></span><code>➜ v4l2-ctl --device=/dev/video0 --all
Driver name   : uvcvideo
Capabilities  : Video Capture, Streaming
</code></pre></div>
<div class="highlight"><pre><span></span><code>➜ v4l2-ctl --device=/dev/video2 --all
Driver name   : vivid
Capabilities  : Video Capture, Streaming
</code></pre></div>
<p>Format negotiation follows the same path as well:</p>
<div class="highlight"><pre><span></span><code>➜ v4l2-ctl -d /dev/video2 --list-formats
[0]: 'YUYV' (YUYV 4:2:2)
</code></pre></div>
<p>From the application’s point of view, there is no special-case logic here. Devices are opened the same way, formats are negotiated through the same ioctls, and frames are streamed using the same buffer APIs. If the driver speaks V4L2 correctly, user space does not care whether frames originate from a sensor or from a kernel generator.</p>
<p>This makes vivid useful for integration testing, but also defines its limits. It does not model sensor quirks, ISP behavior, or vendor-specific timing details. Those belong in hardware-in-the-loop testing. What vivid does cover is the V4L2 surface itself: format negotiation, buffer handling, sequencing, and timing semantics. That is where many integration failures originate.</p>
<h2 id="structuring-integration-tests-around-virtual-devices">Structuring integration tests around virtual devices<a class="headerlink" href="#structuring-integration-tests-around-virtual-devices" title="Permanent link">¶</a></h2>
<p>Once vivid is available, the main job is keeping integration tests honest. They should fail when the runner is not prepared, and they should not depend on accidental details like <code>/dev/video0</code> ordering.</p>
<p>In the repo, that logic lives in one place: a sysfs-backed discovery function plus a couple of “hard requirement” macros. The discovery code reads <code>/sys/class/video4linux/video*/name</code>, filters for devices that contain <code>vivid</code>, then verifies the device can actually be opened before returning it. That avoids probing real cameras and makes failures deterministic.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// This is a snippet but NOT a real code.</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">vivid_devices</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">fs</span><span class="p">::</span><span class="n">read_to_string</span><span class="p">(</span>
<span class="w">                </span><span class="fm">format!</span><span class="p">(</span><span class="s">"/sys/class/video4linux/video{}/name"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="p">).</span><span class="n">unwrap_or_default</span><span class="p">();</span>

<span class="w">            </span><span class="n">name</span><span class="p">.</span><span class="n">to_lowercase</span><span class="p">().</span><span class="n">contains</span><span class="p">(</span><span class="s">"vivid"</span><span class="p">)</span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">V4L2Device</span><span class="p">::</span><span class="n">open</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">is_ok</span><span class="p">()</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>The tests deliberately <strong>do not skip</strong> when vivid is missing. They panic with an actionable error, because this is the class of failures CI must catch early. The single-device macro is used for general “can open / can stream” tests.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// This is a snippet but NOT a real code.</span>
<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">require_vivid</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vivid_devices</span><span class="p">()</span>
<span class="w">            </span><span class="p">.</span><span class="n">first</span><span class="p">()</span>
<span class="w">            </span><span class="p">.</span><span class="n">copied</span><span class="p">()</span>
<span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">"vivid device not found; run dev-setup.sh load-vivid"</span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>Some tests depend on <strong>two devices</strong>, because <code>dev-setup.sh</code> configures them with different patterns. That is where <code>require_vivid_pair!()</code> comes in: it asserts a pair exists and returns <code>(devices[0], devices[1])</code>. If the runner only has one vivid node, or vivid was loaded with the wrong parameters, it fails loudly.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// This is a snippet but NOT a real code.</span>
<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">require_vivid_pair</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">devs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vivid_devices</span><span class="p">();</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">            </span><span class="n">devs</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">            </span><span class="s">"expected two vivid devices; check vivid module configuration"</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="p">(</span><span class="n">devs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">devs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="w">    </span><span class="p">}};</span>
<span class="p">}</span>
</code></pre></div>
<p>From there, the test body stays intentionally boring: open device, set a known format, create a small stream, pull frames, validate invariants. The format choice is fixed (<code>640x480 YUYV</code>) so that frame sizing and pixel access are stable across runs.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2Device</span><span class="p">::</span><span class="n">open</span><span class="p">(</span><span class="n">device_index</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">"Failed to open vivid device"</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">requested</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Format</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="n">FourCC</span><span class="p">::</span><span class="n">YUYV</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="n">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">set_format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">requested</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">"Failed to set format"</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">create_stream</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">"Failed to create stream"</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">next_frame</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">"Failed to capture frame"</span><span class="p">);</span>
</code></pre></div>
<p>One operational detail matters here: these tests are marked <code>#[serial]</code>. Kernel-backed devices are shared state. Even if the runner is “preconfigured”, concurrent open/stream/close sequences against the same nodes tend to create noise. Serializing keeps failures attributable.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span>
<span class="cp">#[serial]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">test_vivid_capture_single_frame</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>The pattern-specific tests show why having a pair matters. The first device is expected to be configured as a gradient, the second as color bars, and the validations fail with messages that point back to the setup script.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">gradient_device</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">require_vivid_pair</span><span class="o">!</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">validate_gradient</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">format</span><span class="p">);</span>
<span class="fm">assert!</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">is_ok</span><span class="p">(),</span><span class="w"> </span><span class="s">"Gradient validation failed on first vivid device..."</span><span class="p">);</span>
</code></pre></div>
<p>This structure keeps the integration suite predictable: the environment requirements are explicit, discovery is deterministic, and the tests exercise the same public API surface as production code.</p>
<h2 id="validating-frame-content-and-metadata">Validating frame content and metadata<a class="headerlink" href="#validating-frame-content-and-metadata" title="Permanent link">¶</a></h2>
<p>Streaming frames is a weak signal. A lot of broken pipelines still stream.</p>
<p>The typical failure is boring and expensive: format negotiation succeeds, buffers flow, sizes look right, and nothing errors out. Then someone notices the image is wrong, or timestamps jump, or sequence numbers reset under load. By that point it is usually on hardware, and it is already hard to localize.</p>
<p>Virtual devices help because the output is predictable. That makes it reasonable to assert properties of frames instead of just checking that data exists.</p>
<p>Start with metadata. Sequence numbers should increase. Timestamps should be present and ordered. If this fails, the pipeline is already violating assumptions downstream components rely on.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">frames</span><span class="p">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Frame</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">next_frame</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">"capture failed"</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span>

<span class="k">for</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">frames</span><span class="p">.</span><span class="n">windows</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sequence</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sequence</span><span class="p">);</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">timestamp</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">timestamp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Content checks can stay minimal. vivid can generate fixed patterns. A couple of pixel samples are enough to catch the usual class of mistakes: wrong stride, wrong pixel format assumptions, or broken conversion logic.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">pixel_at</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">pixel_at</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="fm">assert!</span><span class="p">(</span><span class="n">r2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r1</span><span class="p">);</span>
</code></pre></div>
<p>This is not image quality testing. It is a sanity check that the pipeline interprets the kernel’s buffers the way it thinks it does. Once metadata and minimal content checks are in place, the integration suite stops answering “did we get a frame” and starts answering “did we handle the frame correctly”.</p>
<hr>
<p>Virtual-device integration tests do not replace unit tests or hardware-in-the-loop testing. Unit tests still cover logic and edge cases. HIL still covers hardware-specific behavior. The integration layer sits in between, exercising real syscalls, ioctls, buffer queues, and timing semantics without depending on physical devices. This catches kernel-boundary failures early and pushes HIL back to what it is good at, rather than using it as the first line of integration testing.</p>









  




                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer">
        
          
          <a href="../01-rust-on-pi/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Cross-Compiling Rust for Raspberry Pi">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Cross-Compiling Rust for Raspberry Pi
              </div>
            </div>
          </a>
        
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://gtog.dev/feed_rss_created.xml" target="_blank" rel="noopener" title="gtog.dev" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M64 32C28.7 32 0 60.7 0 96v320c0 35.3 28.7 64 64 64h320c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64zm32 104c0-13.3 10.7-24 24-24 137 0 248 111 248 248 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200-13.3 0-24-10.7-24-24m0 96c0-13.3 10.7-24 24-24 83.9 0 152 68.1 152 152 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104-13.3 0-24-10.7-24-24m0 120a32 32 0 1 1 64 0 32 32 0 1 1-64 0"></path></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://github.com/astavonin/glass-to-glass" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"></path></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.indexes", "navigation.instant", "navigation.footer", "search.suggest", "search.highlight", "content.code.copy", "content.code.annotate", "toc.follow", "navigation.sections", "navigation.tabs", "toc.integrate"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  
<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(()=>{ lightbox.reload(); });
</script></body></html>